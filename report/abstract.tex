\begin{abstract}
%
Despite many advances in program synthesis for functional
languages, the problem of synthesizing expressions in the
untyped lambda calculus remains largely unexplored.
%
In this work we study this problem identifying that its key
challenge is coming up with a practical approach for the
definition of behavioral constraints.
%
We develop some general principles serving as the basis to
specify functions beyond its extensional behavior.
%
This idea is expressive enough to specify in detail the
behavior of functions over a given data encoding.
%
We then show how to extend these principles to build
\emph{co-specifications} for data types and functions on
them unlocking the possibility of automatically deriving
data encodings as a product of synthesis.
%
Finally, we implemented these ideas in a prototype
enumerative synthesizer proving they are useful in practice
to specify the behavior of functions for their synthesis.
\end{abstract}

